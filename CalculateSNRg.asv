2% SNRg Calculations

clear;
clc;
close all;

% Choose settings (0 = off, 1 = on)
ParsevalSNR = 1; 
OldWeight = 0;
Animation = 0;
NequalNseg = 1;
PlotSNRvsParam = 0;
PlotLastTimeSegment = 0;
PlotTSvsi_log = 0;
OutputFile1 = 1;
OutputFile2 = 0;
OutputFile3 = 0;
OutputFile4 = 0;

if (OutputFile3 == 1)
    global StepSize_in; %#ok<NUSED,*TLEV>
    global StepSize_invec; %#ok<NUSED,*TLEV,*GVMIS>
end

TS = 'fdot'; % Choose 'f' or 'fdot'

%% Generate Data Spectrogram

% {SNRg_i | M<=i<=N} will be calculated
M = 1;
N = 100;
Ntrial = 10;
if (OutputFile1 == 0 && OutputFile4 == 0)
    Ntrial = 1;
end

% Set information on noise samples
nNoiseSample = 10;
noiseOffset = 100;
nBinSide = 4;

% Sampling frequency
fsamp = 32.;

% Noise ASD ( / sqrt(Hz) )
hnoise = 12;
noiseamp = hnoise;

% Signal amplitude (no antenna pattern) 
hamp = 1;

% Signal initial frequency (Hz)
f_sig = 10.;

% Signal frequency derivative (Hz/s)
fdot_sig = -5.e-6;

% Length of observation (hr)
Tobs_hr = 4.;
Tobs = Tobs_hr * 3600.;

% Coherence time (hr) - choose so that signal drifts 0.5 bin per coherence time
if (abs(fdot_sig) > 0)
    Tcoh_hr = 1./3600.*sqrt(0.5/abs(fdot_sig));
else
    Tcoh_hr = 1./3600.*sqrt(0.5/abs(-5.e-6));
end
Tcoh = Tcoh_hr * 3600.;

% Adjust coherence time to be an integer number of seconds
Tcoh = floor(Tcoh);
Tcoh_hr = Tcoh/3600.;

% Adjust observation time to be exactly an integer number of coherence times to avoid binning headaches
Nseg = floor(Tobs/Tcoh);
if (NequalNseg == 1)
    N = Nseg;
    %N = floor(Nseg/10)*10;
end
Tobs = Nseg*Tcoh;
Tobs_hr = Tobs / 3600.;
fprintf('Observation time = %d sec (%f hr)\n',Tobs,Tobs_hr);
fprintf('Coherence time per segment = %d sec (%f hr)\n',Tcoh,Tcoh_hr);
assert(M<=N, 'Error: M>N');
if (OutputFile1 == 1)
    if (ParsevalSNR == 1)
        filename1 = sprintf('SNRgfdot_%0.es-2Tobs_%0.fhrnoiseamp_%.2esqrt(s)sigamp_%.2eP.csv', fdot_sig, Tobs_hr, hnoise, hamp);
    else
        filename1 = sprintf('SNRgfdot_%0.es-2Tobs_%0.fhrnoiseamp_%.2esqrt(s)sigamp_%.2e.csv', fdot_sig, Tobs_hr, hnoise, hamp);
    end
end
if (OutputFile4 == 1)
    if (ParsevalSNR == 1)
        filename4 = sprintf('SNRgDenominatorfdot_%0.es-2Tobs_%0.fhrnoiseamp_%.2esqrt(s)sigamp_%.2eP.csv', fdot_sig, Tobs_hr, hnoise, hamp);
    else
        filename4 = sprintf('SNRgDenominatorfdot_%0.es-2Tobs_%0.fhrnoiseamp_%.2esqrt(s)sigamp_%.2e.csv', fdot_sig, Tobs_hr, hnoise, hamp);
    end
end

% Calculate template spacings from model
SNRgModelParams = readmatrix('SNRgModelParams.csv');
TS_model = @(a, i, Tobs, fdot) 10^a(4)*Tobs^a(1)*i^a(2)*abs(fdot)^a(3);

% Create vector of f/fdot values (for search)
searchScale = 10;
fStepSize = TS_model(SNRgModelParams(1, :), (M+N)/2, Tobs_hr, fdot_sig);
if (abs(fdot_sig) > 0)
    fdotStepSize = TS_model(SNRgModelParams(2, :), (M+N)/2, Tobs_hr, fdot_sig);
else
    fdotStepSize = TS_model(SNRgModelParams(2, :), (M+N)/2, Tobs_hr, -5.e-6);
end
if (strcmp(TS, 'f'))
    fvec = (f_sig - searchScale*fStepSize):fStepSize:(f_sig + searchScale*fStepSize);
    fdotvec = fdot_sig;
    SNRg_iArray = zeros(N-M+1, length(fvec));
else
    fvec = f_sig;
    fdotvec = (fdot_sig - searchScale*fdotStepSize):fdotStepSize:(fdot_sig + searchScale*fdotStepSize);
    SNRg_iArray = zeros(N-M+1, length(fdotvec));
end

% Set noise power mean from Parseval's Theorem
noiseMeanPower = Tcoh*fsamp*noiseamp^2;

% Define time series to hold raw data stream of signal plus noise
deltat = 1./fsamp;
t = 0:deltat:Tobs;
Nsample = length(t);

% Search band width (Hz)
bandscale = 115; % Increase if fIndex is too high/low
f_siglo = min(f_sig,f_sig+fdot_sig*Tobs);
f_sighi = max(f_sig,f_sig+fdot_sig*Tobs);
freqlo_approx = min(fvec)+min(fdotvec)*Tobs - (noiseOffset + nNoiseSample + nBinSide)/Tcoh - bandscale/Tcoh;
freqhi_approx = max(fvec) + max(fdotvec)*Tobs*(max(fdotvec) > 0) + (noiseOffset + nNoiseSample + nBinSide)/Tcoh + bandscale/Tcoh;
freqhi = ceil(freqhi_approx * Tcoh)/Tcoh;
freqlo = floor(freqlo_approx * Tcoh)/Tcoh;
bandwidth = freqhi - freqlo;
fprintf('Low/high frequencies of band shown: %f-%f Hz\n',freqlo,freqhi);

% Number of bins signal drifts per coherence time
Nbin_drift = abs(fdot_sig) * Tcoh * Tcoh;
Nbin_drift_total = abs(fdot_sig) * Tobs * Tcoh;
fprintf('Number of bins signal drifts per coherence time = %8.2f\n',Nbin_drift);
fprintf('Total number of bins signal drifts = %8.2f\n',Nbin_drift_total);

for trial = 1:Ntrial
    % Generate noise
    
    noise = noiseamp*random('norm',0.,1.,1.,Nsample);

    % Generate signal in time domain
    signal = hamp*sin(2*pi*(f_sig*t + 0.5*fdot_sig*t.^2));
    data = signal + noise;

    % Generate spectra for each coherence time and extract band of interest to make spectrogram
    indbandlo = floor(freqlo*Tcoh)+1;
    indbandhi = floor(freqhi*Tcoh)+1;
    nbandbin = indbandhi - indbandlo + 1;
    Nseg = floor(Tobs/Tcoh);
    Nsample_coh = floor(Nsample / Nseg);
    spectrogram = zeros(nbandbin,Nseg);
    rawSpectrogram = (1+sqrt(-1)).*zeros(nbandbin,Nseg);
    for seg = 1:Nseg
       fprintf('Generating segment %d\n',seg);
       indlo = (seg-1)*Nsample_coh + 1;
       indhi = indlo + Nsample_coh - 1;
       segment = data(indlo:indhi);
       segment_noNoise = signal(indlo:indhi);
       rawfft = fft(segment,Nsample_coh);
       spectrogram(1:nbandbin,seg) = abs(rawfft(indbandlo:indbandhi));
       rawSpectrogram(1:nbandbin,seg) = rawfft(indbandlo:indbandhi);
       [dummyVariable, fIndex_sig] = max(rawfft(indbandlo:indbandhi));
       if (seg == round(Nseg/5) || seg == round(Nseg/5*2) || seg == round(Nseg/5*3) || seg == round(Nseg/5*4) || seg == Nseg)
           fprintf('Signal fIndex of segment %d = %d; magnitude = %d; phase = %d\n', seg, fIndex_sig, abs(dummyVariable), angle(dummyVariable));
       end
    end

    % Create modified spectrogram for plot
    plotSpectrogram = spectrogram;
    for k = 1:Nseg
        segment = plotSpectrogram(:, k);
        segment(segment < 0.1*max(segment)) = 0;
        plotSpectrogram(:, k) = segment;
    end

    % Plot spectrogram bar3(spectrogram)
    segarray = 1:Nseg;
    seghour = (segarray-1)*Tcoh/3600.;
    indarray = [indbandlo:indbandhi];
    freqplot = (indarray-indbandlo)*1.0/Tcoh + freqlo;
    
    if (Nseg > 1)
        figure(1);
        fprintf('Creating spectrogram plot with %d time bins (columns) and %d frequency bins (rows)...\n',Nseg,nbandbin);
        s1 = surf(seghour,freqplot,plotSpectrogram);
        s1.EdgeAlpha = 0.5;
        title('Raw spectrogram');
        xlabel('Time (hours)');
        ylabel('Frequency (Hz)');
        view(0,90);
        ax = gca;
        ax.FontSize = 18;
        ax.LineWidth = 3;
        axis([min(seghour) max(seghour) min(freqplot) max(freqplot)]);
    end

    %% Calculate Detection Statistics

    % Create vector of indices for frequency trajectory in the middle of each time segment
    freqTrajIndex = round(((1:Nseg) - 0.5).*Nsample_coh) + 1;
    tMid = t(freqTrajIndex);

    % Calculate expected phase/frequency trajectories and signal
    freqTraj = f_sig + fdot_sig.*tMid;
    phaseTraj = 2*pi.*(f_sig.*t + 0.5*fdot_sig.*t.^2);
    searchSignal = hamp.*sin(phaseTraj);

    % Create template spectrogram
    searchSpectrogram = (1+sqrt(-1)).*zeros(nbandbin,Nseg);
    for seg = 1:Nseg
        indlo = (seg-1)*Nsample_coh + 1;
        indhi = indlo + Nsample_coh - 1;
        searchSegment = searchSignal(indlo:indhi);
        searchRawfft = fft(searchSegment, Nsample_coh);
        searchSpectrogram(1:nbandbin,seg) = searchRawfft(indbandlo:indbandhi);
    end

    % Calculate signal frequency indices
    fIndex = round((freqTraj-freqlo)*Tcoh) + 1;

    % Calculate background noise frequency indices
    fIndex_noise = zeros(nNoiseSample, Nseg);
    for k = 1:nNoiseSample
        fIndex_noise(k, :) = fIndex + (2*nBinSide+2)*k + noiseOffset;
    end

    % Calculate weightedFFTs array
    if (OldWeight == 1)
        weight = zeros(nbandbin, Nseg);
    else
        weight = zeros(1, Nseg);
    end
    weightedFFT = (1+sqrt(-1)).*zeros(nbandbin,Nseg);
    for tIndex = 1:Nseg
        if (OldWeight == 1)
            weight(:, tIndex) = abs(searchSpectrogram(:, tIndex)).^2/sum(abs(searchSpectrogram((fIndex(tIndex)-nBinSide):(fIndex(tIndex)+nBinSide), tIndex)).^2);
            weightedFFT(:, tIndex) = searchSpectrogram(:, tIndex).*weight(:, tIndex);
        else
            weight(tIndex) = 1/sqrt(sum(abs(searchSpectrogram((fIndex(tIndex)-nBinSide):(fIndex(tIndex)+nBinSide), tIndex)).^2));
            weightedFFT(:, tIndex) = weight(tIndex).*searchSpectrogram(:, tIndex);
        end
    end
    
    % Calculate detection statistics
    signalDSg_i = zeros(N-M+1, 1);
    grouper_sig = (1+sqrt(-1)).*zeros(N-M+1, 1);
    noiseDSg_i = (1+sqrt(-1)).*zeros(N-M+1, nNoiseSample);
    grouper_noise = (1+sqrt(-1)).*zeros(N-M+1, nNoiseSample);

    signalDSContribution1 = [];
    signalDSContribution2 = [];
    signalDSContribution3 = [];
    signalDSContribution4 = [];

    noiseDSContribution1 = [];
    noiseDSContribution2 = [];
    noiseDSContribution3 = [];
    noiseDSContribution4 = [];

    for tIndex = 1:Nseg
        % Signal detection statistics
        grouper_sig = grouper_sig + sum(conj(weightedFFT((fIndex(tIndex)-nBinSide):(fIndex(tIndex)+nBinSide), tIndex)).*rawSpectrogram((fIndex(tIndex)-nBinSide):(fIndex(tIndex)+nBinSide), tIndex));
        for i = M:N

            contribution = abs(grouper_sig(i-M+1))^2;

            if (mod(tIndex, i) == 0)
                signalDSg_i(i-M+1) = signalDSg_i(i-M+1) + contribution;
                if (i == 1)
                    signalDSContribution1 = [signalDSContribution1, contribution];
                elseif (i == 2)
                    signalDSContribution2 = [signalDSContribution2, contribution];
                elseif (i == 3)
                    signalDSContribution3 = [signalDSContribution3, contribution];
                elseif (i == 4)
                    signalDSContribution4 = [signalDSContribution4, contribution];
                end
                grouper_sig(i-M+1) = 0;
            elseif (tIndex == Nseg)
                signalDSg_i(i-M+1) = signalDSg_i(i-M+1) + contribution;
                grouper_sig(i-M+1) = 0;
            end
        end

        % Noise detection statistics
        for k = 1:nNoiseSample
            grouper_noise(:, k) = grouper_noise(:, k) + sum(conj(weightedFFT((fIndex(tIndex)-nBinSide):(fIndex(tIndex)+nBinSide), tIndex)).*rawSpectrogram((fIndex_noise(k, tIndex)-nBinSide):(fIndex_noise(k, tIndex)+nBinSide), tIndex));
        end
        for i = M:N
            
            contribution = abs(grouper_noise(i-M+1, :)).^2;

            if (mod(tIndex, i) == 0)
                noiseDSg_i(i-M+1, :) = noiseDSg_i(i-M+1, :) + contribution;

                if (i == 1)
                    noiseDSContribution1 = [noiseDSContribution1, [abs(grouper_noise(i-M+1, 1))^2; abs(grouper_noise(i-M+1, floor(nNoiseSample/2)))^2; abs(grouper_noise(i-M+1, end))^2]];
                elseif (i == 2)
                    noiseDSContribution2 = [noiseDSContribution2, [abs(grouper_noise(i-M+1, 1))^2; abs(grouper_noise(i-M+1, floor(nNoiseSample/2)))^2; abs(grouper_noise(i-M+1, end))^2]];
                elseif (i == 3)
                    noiseDSContribution3 = [noiseDSContribution3, [abs(grouper_noise(i-M+1, 1))^2; abs(grouper_noise(i-M+1, floor(nNoiseSample/2)))^2; abs(grouper_noise(i-M+1, end))^2]];
                elseif (i == 4)
                    noiseDSContribution4 = [noiseDSContribution4, [abs(grouper_noise(i-M+1, 1))^2; abs(grouper_noise(i-M+1, floor(nNoiseSample/2)))^2; abs(grouper_noise(i-M+1, end))^2]];
                end
                
                grouper_noise(i-M+1, :) = 0;
            elseif (tIndex == Nseg)
                noiseDSg_i(i-M+1, :) = noiseDSg_i(i-M+1, :) + contribution;
            end
        end
    end

    %% Calculate SNRs and Plot
    % Calculate SNRs
    SNRg_i = zeros(N-M+1, 1);
    if (OldWeight == 1)
        noiseMeanDS = noise_mean_DS(weight, searchSpectrogram, noiseMeanPower, Nseg, fIndex, nBinSide);
        noiseStdDS = noise_std_DS(weight, searchSpectrogram, noiseMeanPower, Nseg, fIndex, nBinSide);
    else
        noiseMeanDS = noiseMeanPower*Nseg;
        noiseStdDS = noiseMeanPower*sqrt(Nseg);
    end
    for i = M:N
        if (ParsevalSNR == 0)
            SNRg_i(i-M+1) = abs(signalDSg_i(i-M+1) - mean(noiseDSg_i(i-M+1, :)))/std(noiseDSg_i(i-M+1, :));
        elseif (ParsevalSNR == 1)
            SNRg_i(i-M+1) = abs(signalDSg_i(i-M+1) - noiseMeanDS)/(sqrt(i)*noiseStdDS);
        end

        fprintf('SNRg_%d = %e\n', i, SNRg_i(i-M+1));
    end

    if (OutputFile1 == 1)
        assert(all(M:N==1:Nseg), 'Error: Output File 1 can only function when M=1 and N=Nseg')
        fout1 = fopen(filename1, 'a');
        for i = M:N
            if (i == N)
                fprintf(fout1, '%e\n', SNRg_i(i-M+1));
            else
                fprintf(fout1, '%e,', SNRg_i(i-M+1));
            end
        end
    end
    if (OutputFile4 == 1)
        assert(all(M:N==1:Nseg), 'Error: Output File 4 can only function when M=1 and N=Nseg')
        fout4 = fopen(filename4, 'a');
        for i = M:N
            if (ParsevalSNR == 0)
                if (i == N)
                    fprintf(fout4, '%e\n', std(noiseDSg_i(i-M+1, :)));
                else
                    fprintf(fout4, '%e,', std(noiseDSg_i(i-M+1, :)));
                end
            else 
                if (i == N)
                    fprintf(fout4, '%e\n', sqrt(i)*noiseStdDS);
                else
                    fprintf(fout4, '%e,', sqrt(i)*noiseStdDS);
                end
            end
        end
    end

end

if (OldWeight == 1)
    predSignalDS = pred_signal_DS(weight, searchSpectrogram, noiseMeanPower, Nseg, fIndex, nBinSide);
else
    predSignalDS = Nseg*h0rms(searchSpectrogram, fIndex, Nseg, nBinSide)^2 + noiseMeanDS;
end
iVals = M:N;
perfiVals = iVals(Nseg./iVals == floor(Nseg./iVals));
finei = linspace(M, N, 100*Nseg);

% Plot data
figure(2)
p1 = scatter(M:N, SNRg_i, 'ok');
hold on;
p3 = scatter(perfiVals, abs(predSignalDS - noiseMeanDS)./noiseStdDS.*perfiVals./sqrt(perfiVals), 200, 'p');
p4 = plot(finei, abs(predSignalDS - noiseMeanDS)./noiseStdDS.*finei./sqrt(finei));
p3.LineWidth = 3;
p3.CData = 0.8*[204, 204, 255]/255;
p4.Color = p3.CData;
p4.LineWidth = 3;
title('SNRg_i vs i');
xlabel('i');
ylabel('SNRg_i');
legend('SNRg_i', 'Predicted Values', 'location', 'northwest');
grid on;
p1.LineWidth = 3;
ax = gca;
ax.LineWidth = 3;
ax.FontSize = 16;
hold off;

[imax, SNRg_imax] = max(SNRg_i);
fprintf('Max of %e at i = %d\n', imax, SNRg_imax);

% Print Predictions of SNR from Parseval's Theorem

if (M == 1)
fprintf('\n\t\t***\n');
fprintf('Signal DS_1 (empirical) = %e\n', signalDSg_i(1));
fprintf('Signal DS_1 (predicted) = %e\n', predSignalDS);
fprintf('Mean of Noise DS_1 (empirical) %e\n', mean(noiseDSg_i(1, :)));
fprintf('Mean of Noise DS_1 (predicted) %e\n', noiseMeanDS);
fprintf('Standard Deviation of Noise DS_1 (empirical) = %e\n', std(noiseDSg_i(1, :)));
fprintf('Standard Deviation of Noise DS_1 (predicted) = %e\n', noiseStdDS);
fprintf('SNRg_1 (empirical) = %e\n', abs(signalDSg_i(1)-mean(noiseDSg_i(1, :)))/std(noiseDSg_i(1, :)));
fprintf('SNRg_1 (predicted) = %e\n', abs(predSignalDS - noiseMeanDS)/noiseStdDS);
fprintf('\t\t***\n\n')
end

%% Plot DS Contributions

if (NequalNseg == 1 && M == 1 && Nseg >= 4)
    % Create segment vectors for each SNRg_i
    segvecs = {[], [], [], []};
    for tIndex = 1:Nseg
        for i = 1:4
            if (mod(tIndex, i) == 0)
                segvecs{i} = [segvecs{i}, tIndex];
            end
        end
    end

    figure(3)
    subplot(2, 2, 1)
    p311 = plot(segvecs{1}, signalDSContribution1, '-r');
    hold on;
    p321 = plot(segvecs{2}, signalDSContribution2, '-g');
    p331 = plot(segvecs{3}, signalDSContribution3, '-b');
    p341 = plot(segvecs{4}, signalDSContribution4, '-m');
    hold off;
    ylim([0, 17]);
    title('Signal DS Contributions for SNRg_i');
    xlabel('time segment');
    ylabel('contribution');
    legend('i=1', 'i=2', 'i=3', 'i=4');
    ax = gca;
    ax.LineWidth = 3;
    ax.FontSize = 15;

    subplot(2, 2, 2)
    p312 = plot(segvecs{1}, noiseDSContribution1(1, :), '-r');
    hold on;
    p322 = plot(segvecs{2}, noiseDSContribution2(1, :), '-g');
    p332 = plot(segvecs{3}, noiseDSContribution3(1, :), '-b');
    p342 = plot(segvecs{4}, noiseDSContribution4(1, :), '-m');
    hold off;
    title('Noise DS Contributions for SNRg_i (first noise sample)');
    xlabel('time segment');
    ylabel('contribution');
    legend('i=1', 'i=2', 'i=3', 'i=4');
    ax = gca;
    ax.LineWidth = 3;
    ax.FontSize = 15;

    subplot(2, 2, 3)
    p313 = plot(segvecs{1}, noiseDSContribution1(2, :), '-r');
    hold on;
    p323 = plot(segvecs{2}, noiseDSContribution2(2, :), '-g');
    p333 = plot(segvecs{3}, noiseDSContribution3(2, :), '-b');
    p343 = plot(segvecs{4}, noiseDSContribution4(2, :), '-m');
    hold off;
    title('Noise DS Contributions for SNRg_i (middle noise sample)');
    xlabel('time segment');
    ylabel('contribution');
    legend('i=1', 'i=2', 'i=3', 'i=4');
    ax = gca;
    ax.LineWidth = 3;
    ax.FontSize = 15;

    subplot(2, 2, 4)
    p314 = plot(segvecs{1}, noiseDSContribution1(3, :), '-r');
    hold on;
    p324 = plot(segvecs{2}, noiseDSContribution2(3, :), '-g');
    p334 = plot(segvecs{3}, noiseDSContribution3(3, :), '-b');
    p344 = plot(segvecs{4}, noiseDSContribution4(3, :), '-m');
    hold off;
    title('Noise DS Contributions for SNRg_i (last noise sample)');
    xlabel('time segment');
    ylabel('contribution');
    legend('i=1', 'i=2', 'i=3', 'i=4');
    ax = gca;
    ax.LineWidth = 3;
    ax.FontSize = 15;

end
%% Generate Templates and Calculate SNRs

for r = 1:length(fvec)
    for j = 1:length(fdotvec)
        
        if (strcmp(TS, 'f'))
            fprintf('Calulating SNRg_is for df = %e Hz\n', fvec(r)-f_sig);
        else
            fprintf('Calulating SNRg_is for dfdot = %e Hz/s\n', fdotvec(j)-fdot_sig);
        end
        
        % Calculate expected phase/frequency trajectories and signal
        freqTraj = fvec(r) + fdotvec(j).*tMid; 
        phaseTraj = 2*pi.*(fvec(r).*t + 0.5*fdotvec(j).*t.^2);
        searchSignal = hamp.*sin(phaseTraj);
    
        % Create template spectrogram
        searchSpectrogram = (1+sqrt(-1)).*zeros(nbandbin,Nseg);
        for seg = 1:Nseg
            indlo = (seg-1)*Nsample_coh + 1;
            indhi = indlo + Nsample_coh - 1;
            searchSegment = searchSignal(indlo:indhi);
            searchRawfft = fft(searchSegment, Nsample_coh);
            searchSpectrogram(1:nbandbin,seg) = searchRawfft(indbandlo:indbandhi);
        end
    
        % Calculate signal frequency indices
        fIndex = round((freqTraj-freqlo)*Tcoh) + 1;

        % Calculate background noise frequency indices
        if (ParsevalSNR == 0)
            fIndex_noise = zeros(nNoiseSample, Nseg);
            for k = 1:nNoiseSample
                fIndex_noise(k, :) = fIndex + 10*k + noiseOffset;
            end
        end
    
        % Calculate weightedFFTs array
        if (OldWeight == 1)
            weight = zeros(nbandbin, Nseg);
        else
            weight = zeros(1, Nseg);
        end
        weightedFFT = (1+sqrt(-1)).*zeros(nbandbin,Nseg);
        for tIndex = 1:Nseg
            if (OldWeight == 1)
                weight(:, tIndex) = abs(searchSpectrogram(:, tIndex)).^2/sum(abs(searchSpectrogram((fIndex(tIndex)-nBinSide):(fIndex(tIndex)+nBinSide), tIndex)).^2);
            else
                weight(tIndex) = 1/sqrt(sum(abs(searchSpectrogram((fIndex(tIndex)-nBinSide):(fIndex(tIndex)+nBinSide), tIndex)).^2));
            end
            weightedFFT(:, tIndex) = searchSpectrogram(:, tIndex).*weight(:, tIndex);
        end
        
        % Calculate detection statistics
        signalDSg_i = zeros(N-M+1, 1);
        grouper_sig = (1+sqrt(-1)).*zeros(N-M+1, 1);
        if (ParsevalSNR == 0)
            noiseDSg_i = (1+sqrt(-1)).*zeros(N-M+1, nNoiseSample);
            grouper_noise = (1+sqrt(-1)).*zeros(N-M+1, nNoiseSample);
        end
    
        if (j*r == 15)
            DScontributions15 = zeros(1, Nseg);
        elseif (j*r == 21)
            DScontributions21 = zeros(1, Nseg);
        elseif (j*r == 11)
            DScontribution11 = zeros(1, Nseg);
        end
    
        for tIndex = 1:Nseg
            % Signal detection statistics
            grouper_sig = grouper_sig + sum(conj(weightedFFT((fIndex(tIndex)-nBinSide):(fIndex(tIndex)+nBinSide), tIndex)).*rawSpectrogram((fIndex(tIndex)-nBinSide):(fIndex(tIndex)+nBinSide), tIndex));
            for i = M:N

                contribution = abs(grouper_sig(i-M+1))^2;

                if (mod(tIndex, i) == 0)
                    signalDSg_i(i-M+1) = signalDSg_i(i-M+1) + contribution;
                    if (j*r == 15 && i == 1)
                        DScontributions15(tIndex) = contribution;
                    elseif (j*r == 21 && i == 1)
                        DScontributions21(tIndex) = contribution;
                    elseif (j*r == 11 && i == 1)
                        DScontribution11(tIndex) = contribution;
                    end
                    grouper_sig(i-M+1) = 0;
                elseif (tIndex == Nseg)
                    signalDSg_i(i-M+1) = signalDSg_i(i-M+1) + contribution;
                end
            end
    
            % Noise detection statistics
            if (ParsevalSNR == 0)
                for k = 1:nNoiseSample
                    grouper_noise(:, k) = grouper_noise(:, k) + sum(conj(weightedFFT((fIndex(tIndex)-nBinSide):(fIndex(tIndex)+nBinSide), tIndex)).*rawSpectrogram((fIndex_noise(k, tIndex)-nBinSide):(fIndex_noise(k, tIndex)+nBinSide), tIndex));
                end
                for i = M:N

                    contribution = abs(grouper_noise(i-M+1, :)).^2;
  
                    if (mod(tIndex, i) == 0)
                        noiseDSg_i(i-M+1, :) = noiseDSg_i(i-M+1, :) + contribution;
                        grouper_noise(i-M+1, :) = 0;
                    elseif (tIndex == Nseg)
                        noiseDSg_i(i-M+1, :) = noiseDSg_i(i-M+1, :) + contribution;
                    end
                end
            end
        end
        
        
        if (OldWeight == 1)
            noiseMeanDS = noise_mean_DS(weight, searchSpectrogram, noiseMeanPower, Nseg, fIndex, nBinSide);
            noiseStdDS = noise_std_DS(weight, searchSpectrogram, noiseMeanPower, Nseg, fIndex, nBinSide);
        else
            noiseMeanDS = noiseMeanPower*Nseg;
            noiseStdDS = noiseMeanPower*sqrt(Nseg);
        end
        for i = M:N
            if (ParsevalSNR == 0)
                SNRg_iArray(i-M+1, j*r) = abs(signalDSg_i(i-M+1) - mean(noiseDSg_i(i-M+1, :)))/std(noiseDSg_i(i-M+1, :));
            elseif (ParsevalSNR == 1)
                SNRg_iArray(i-M+1, j*r) = abs(signalDSg_i(i-M+1) - noiseMeanDS)/(sqrt(i)*noiseStdDS);
            end
        end
        
        % Compare search spectrogram and signal spectrogram last time segment
        if (PlotLastTimeSegment == 1)
            range = (fIndex(end)-10):(fIndex(end)+10);
            
            figure(1900+j*r)
            s1900j = scatter(range, abs(searchSpectrogram(range, end)), '*k');
            hold on;
            p1900j = plot(range, abs(rawSpectrogram(range, end)), '-r');
            x1900j = xline(fIndex(end), '--k');
            x1900j.LineWidth = 1;
            s1900j.LineWidth = 3;
            title(['Last Time Segment Fourier Coefficient Magnitude dfdot_{sig} = ', num2str(fdotvec(j) - fdot_sig), ' Hz/s']);
            xlabel('frequency bin');
            ylabel('magnitude');
            legend('template', 'data', 'fIndex');
            ax = gca;
            ax.FontSize = 14;
            ax.LineWidth = 3;
            grid on;
            hold off;
            
            figure(2900+j*r)
            s2900j = scatter(range, unwrap(atan2(imag(searchSpectrogram(range, end)), real(searchSpectrogram(range, end)))), '*k');
            hold on;
            p2900j = plot(range, unwrap(atan2(imag(rawSpectrogram(range, end)), real(rawSpectrogram(range, end)))), '-r');
            x2900j = xline(fIndex(end), '--k');
            x2900j.LineWidth = 1;
            s2900j.LineWidth = 3;
            title(['Last Time Segment Fourier Coefficient Phase dfdot_{sig} = ', num2str(fdotvec(j) - fdot_sig), ' Hz/s']);
            xlabel('frequency bin');
            ylabel('phase');
            legend('template', 'data', 'fIndex');
            ax = gca;
            ax.FontSize = 14;
            ax.LineWidth = 3;
            grid on;
            hold off;
        end
    end
end

if (searchScale >= 20)
    figure(3000)
    p39001 = plot(1:Nseg, DScontributions15, '-g');
    hold on;
    p39002 = plot(1:Nseg, DScontributions21, '-m');
    p39003 = plot(1:Nseg, DScontribution11, '-b');
    hold off;
    title('Center Bin and Off Bin DS Contributions(i == 1)')
    xlabel('time segment')
    ylabel('DS Contribution')
    legend('off bin with max SNR', 'center bin', 'off bin with lower SNR')
    ax = gca;
    ax.FontSize = 16;
    ax.LineWidth = 3;
    grid on;
end

%% Plot data for deviations in fdot

% Create titles
titleStrings = cell(1, N-M+1);
for i = M:N
    if (strcmp(TS, 'f'))
        titleStrings{i-M+1} = sprintf('SNRg_{%d} vs df', i);
    else
        titleStrings{i-M+1} = sprintf('SNRg_{%d} vs dfdot', i);
    end
end
df = fvec-f_sig;
dfdot = fdotvec-fdot_sig;

% Plot SNRg_i vs i
for k = 1:(length(dfdot)*length(df))
    figure(3+k)
    sk1 = scatter(M:N, SNRg_iArray(:, k), 'ok');
    if (strcmp(TS, 'f'))
        title(['SNRg_i vs i for dfdot = ', num2str(df(k))]);
    else
        title(['SNRg_i vs i for dfdot = ', num2str(dfdot(k))]);
    end
    xlabel('i');
    ylabel('SNRg_i');
    grid on;
    ax = gca;
    ax.LineWidth = 3;
    ax.FontSize = 16;
end

% Plot SNRg_i vs dfdot
if (PlotSNRvsParam == 1)
    for i = M:N
        figure(3+length(dfdot)*length(df)+i-M+1)
        subplot(1, 2, 1)
        hold on;        
        if (strcmp(TS, 'f'))
            si1 = scatter(df, SNRg_iArray(i-M+1, :)/SNRg_iArray(i-M+1, searchScale+1), 'ok');
            xlabel('df (Hz)');
        else
            si1 = scatter(dfdot, SNRg_iArray(i-M+1, :)/SNRg_iArray(i-M+1, searchScale+1), 'ok');
            xlabel('dfdot (Hz/s)');
        end
        title(titleStrings{i-M+1});
        ylabel('SNR/SNR_m_a_x');
        legend(['i = ', num2str(i)])
        grid on;
        ax = gca;
        ax.LineWidth = 3;
        ax.FontSize = 16;

        subplot(1, 2, 2)
        if (strcmp(TS, 'f'))
            si2 = scatter(df, SNRg_iArray(i-M+1, :), 'ok');
            xlabel('df (Hz)');
        else
            si2 = scatter(dfdot, SNRg_iArray(i-M+1, :), 'ok');
            xlabel('dfdot (Hz/s)');
        end
        title(titleStrings{i-M+1});
        ylabel('SNR');
        legend(['i = ', num2str(i)])
        grid on;
        ax = gca;
        ax.LineWidth = 3;
        ax.FontSize = 16;
    end
end

%% Animation
if (Animation == 1)
    figure(4+length(dfdot)*length(df)+N-M+1)
    if (strcmp(TS, 'f'))
        sgtitle('SNRg_i vs df for Various i', 'FontSize', 20);
    else
        sgtitle('SNRg_i vs dfdot for Various i', 'FontSize', 20);
    end
    for repeat = 1:3
        for i = M:N
            subplot(1, 2, 1)
            if (strcmp(TS, 'f'))
                scatter(df, SNRg_iArray(i-M+1, :)/max(SNRg_iArray(i-M+1, :)), 'ok');
                axis([1.01*min(df), 1.01*max(df), 0, 1]);
                xlabel('df (Hz)');
            else
                scatter(dfdot, SNRg_iArray(i-M+1, :)/max(SNRg_iArray(i-M+1, :)), 'ok');
                axis([1.01*min(dfdot), 1.01*max(dfdot), 0, 1]);
                xlabel('dfdot (Hz/s)');
            end
            ylabel('SNR/SNR_m_a_x');
            legend(['i = ', num2str(i)]);
            title('Normalized');
            ax = gca;
            ax.LineWidth = 3;
            ax.FontSize = 16;
            grid on;

            subplot(1, 2, 2)
            scatter(dfdot, SNRg_iArray(i-M+1, :), 'ok');
            axis([1.01*min(dfdot), 1.01*max(dfdot), 0, max(SNRg_iArray(:))]);
            xlabel('dfdot (Hz/s)');
            ylabel('SNR');
            legend(['i = ', num2str(i)]);
            title('Not Normalized');
            ax = gca;
            ax.LineWidth = 3;
            ax.FontSize = 16;
            grid on;
            pause(0.5)
        end
    end
end
%% Fit SNRg_i to Curve in Parameter Space to Calculate TS

if (strcmp(TS, 'f'))
    dfp = linspace(min(df), max(df), 1.e4*length(df));
    dfdotp = dfdot;
else
    dfp = df;
    dfdotp = linspace(min(dfdot), max(dfdot), 1.e4*length(dfdot));
end
SNRsplines = zeros(N-M+1, length(dfdotp)*length(dfp));
templateSpacings = zeros(N-M+1, 1);

for i = M:N
    if (strcmp(TS, 'f'))
        SNRsplines(i-M+1, :) = spline(df, SNRg_iArray(i-M+1, :), dfp);
        [ignore1, indRight] = min(abs(SNRsplines(i-M+1, (floor(end/2)+1):end) - 0.8*SNRg_iArray(i-M+1, searchScale+1)));
        [ignore2, indLeft] = min(abs(SNRsplines(i-M+1, 1:floor(end/2)) - 0.8*SNRg_iArray(i-M+1, searchScale+1)));
        TS_right =  mode(abs(dfp(indRight + floor(end/2))));
        TS_left =  mode(abs(dfp(indLeft)));
        templateSpacings(i-M+1) = mean([TS_left, TS_right]);
    else
        SNRsplines(i-M+1, :) = spline(dfdot, SNRg_iArray(i-M+1, :), dfdotp);
        [ignore1, indRight] = min(abs(SNRsplines(i-M+1, (floor(end/2)+1):end) - 0.8*SNRg_iArray(i-M+1, searchScale+1)));
        [ignore2, indLeft] = min(abs(SNRsplines(i-M+1, 1:floor(end/2)) - 0.8*SNRg_iArray(i-M+1, searchScale+1)));
        TS_right =  mode(abs(dfdotp(indRight + floor(end/2))));
        TS_left =  mode(abs(dfdotp(indLeft)));
        templateSpacings(i-M+1) = mean([TS_left, TS_right]);
    end
    
    if (PlotSNRvsParam == 1)
        figure(3+length(dfdot)*length(df)+i-M+1)
        subplot(1, 2, 1)
        hold on;
        if (strcmp(TS, 'f'))
            pi1 = plot(dfp, SNRsplines(i-M+1, :)/SNRg_iArray(i-M+1, searchScale+1));
        else
            pi1 = plot(dfdotp, SNRsplines(i-M+1, :)/SNRg_iArray(i-M+1, searchScale+1));
        end
        legend(['i = ', num2str(i)], 'spline', 'Location', 'south')

        subplot(1, 2, 2)
        hold on;
        if (strcmp(TS, 'f'))
            pi2 = plot(dfp, SNRsplines(i-M+1, :));
            
        else
            pi2 = plot(dfdotp, SNRsplines(i-M+1, :));
        end
        legend(['i = ', num2str(i)], 'spline', 'Location', 'south')
    end
end


for i = M:N
    if (strcmp(TS, 'f'))
        fprintf('For i = %d, stepping %e Hz in f causes a 20%% drop in SNRg_i\n', i, templateSpacings(i-M+1));
    else
        fprintf('For i = %d, stepping %e Hz/s in fdot causes a 20%% drop in SNRg_i\n', i, templateSpacings(i-M+1));
    end
end

% Plot Template Spacings
if (strcmp(TS, 'f'))
    filename2 = sprintf('SNRgfTemplateSpacingfdot_%0.eP.csv', fdot_sig);
else
    filename2 = sprintf('SNRgfdotTemplateSpacingfdot_%0.eP.csv', fdot_sig);
end
Data = readmatrix(filename2);
Data = Data(round(Data(:, 1)) == round(Tobs_hr), 2:3);
X = zeros(1, Nseg);
for i = 1:N
    X(i) = mean(Data(round(Data(:, 1)) == round(i), 2));
end

figure(1000000)
s1000000 = scatter(log10(M:N), log10(templateSpacings));
hold on;
p1000000 = plot(log10(M:N), log10(X),  '-r');
s1000000.MarkerFaceColor = 'k';
title('Template Spacing vs i');
xlabel('log(i)');
if (strcmp(TS, 'f'))
    ylabel('log(df) (log(Hz))');
else
    ylabel('log(dfdot) (log(Hz/s))');
end
legend('Calculated Now', 'Previously Calculated')
ax = gca;
ax.FontSize = 16;
ax.LineWidth = 3;
grid on;
hold off;


if (OutputFile2 == 1)
    if (strcmp(TS, 'f'))
        if (ParsevalSNR == 1)
            filename2 = sprintf('SNRgfTemplateSpacingfdot_%0.eP.csv', fdot_sig);
        else
            filename2 = sprintf('SNRgfTemplateSpacingfdot_%0.e.csv', fdot_sig);
        end
    else
        if (ParsevalSNR == 1)
            filename2 = sprintf('SNRgfdotTemplateSpacingfdot_%0.eP.csv', fdot_sig);
        else
            filename2 = sprintf('SNRgfdotTemplateSpacingfdot_%0.e.csv', fdot_sig);
        end
    end
    fout2 = fopen(filename2, 'a');
    for i = M:N
        fprintf(fout2, '%f, %d, %e\n', Tobs_hr, i, templateSpacings(i-M+1));
    end
end

if (OutputFile3 == 1)
    assert(all(M:N==1:Nseg), 'Error: Output File 3 can only function when M=1 and N=Nseg')
    if (strcmp(TS, 'f'))
        if (ParsevalSNR == 1)
            filename3 = sprintf('SNRgfTemplateSpacingvsStepSizefdot_%0.eTobs_%0.fP.csv', fdot_sig, Tobs_hr);
        else
            filename3 = sprintf('SNRgfTemplateSpacingvsStepSizefdot_%0.eTobs_%0.f.csv', fdot_sig, Tobs_hr);
        end
    else
        if (ParsevalSNR == 1)
            filename3 = sprintf('SNRgfdotTemplateSpacingvsStepSizefdot_%0.eTobs_%0.fP.csv', fdot_sig, Tobs_hr);
        else
            filename3 = sprintf('SNRgfdotTemplateSpacingvsStepSizefdot_%0.eTobs_%0.f.csv', fdot_sig, Tobs_hr);
        end
    end
    fout3 = fopen(filename3, 'a');
    if (strcmp(TS, 'f'))
        fprintf(fout3, '%e,', fStepSize);
    else
        fprintf(fout3, '%e,', fdotStepSize);
    end
    for i = M:N
        if (i == N)
            fprintf(fout3, '%e\n', templateSpacings(i-M+1));
        else
            fprintf(fout3, '%e,', templateSpacings(i-M+1));
        end
        
    end
end

%% Plot log-log graph
if (PlotTSvsi_log == 1)
    templateFitCoeffs = polyfit(log10(M:N), log10(templateSpacings), 1);

    figure(5+length(dfdot)+N)
    p5fN = plot(log10(M:N), log10(abs(fitCoeffs*sqrt(log(5/4)))), '-k');
    hold on;
    p5fN2 = plot(log10(M:N), -2*(log10(M:N)-log10(N)) + log10(abs(fitCoeffs(N)*sqrt(log(5/4)))), '-r');
    p5fN1 = plot(log10(M:N), -1*(log10(M:N)-log10(N)) + log10(abs(fitCoeffs(N)*sqrt(log(5/4)))), '-g');
    p5fNh = plot(log10(M:N), -0.5*(log10(M:N)-log10(N)) + log10(abs(fitCoeffs(N)*sqrt(log(5/4)))), '-b');
    p5fNf = plot(log10(M:N), -0.25*(log10(M:N)-log10(N)) + log10(abs(fitCoeffs(N)*sqrt(log(5/4)))), '-m');
    p5fNfit = plot(log10(M:N), templateFitCoeffs(1).*log10(M:N) + templateFitCoeffs(2));
    xlim([log10(M), log10(N)]);
    title('dfdot for 20% Offset in SNRg_i vs i (log-log)');
    xlabel('log(i)');
    ylabel('log(dfdot)');
    legend('dfdot values', 'line through last point with slope = -2', 'line through last point with slope = -1', 'line through last point with slope = -1/2', 'line through last point with slope = -1/4', 'linear fit');
    p5fN.LineWidth = 3;
    p5fN2.LineWidth = 2;
    p5fN1.LineWidth = 2;
    p5fNh.LineWidth = 2;
    p5fNf.LineWidth = 2;
    p5fNfit.LineWidth = 2.5;
    p5fNfit.Color = [0.7, 0.7, 0.2];
    ax = gca;
    ax.LineWidth = 3;
    ax.FontSize = 16;
    grid on; 
    hold off;

fprintf('Template spacing for Tobs = %f hr: dfdot = %e * i^(%f)\n', Tobs_hr, 10^(templateFitCoeffs(2)), templateFitCoeffs(1));
end

%% Functions 

% Calculate mean noise detection statistic from weights and signal spectrogram
function [D_n] = noise_mean_DS(W, S, A, Nseg, fIndex, nBinSide)
    D_n = 0;
    for tIndex = 1:Nseg
        D_n = D_n + sum(W((fIndex(tIndex)-nBinSide):(fIndex(tIndex)+nBinSide), tIndex).^2 .* abs(S((fIndex(tIndex)-nBinSide):(fIndex(tIndex)+nBinSide), tIndex)).^2);
    end
    D_n = A*D_n;
end

% Calculate standard deviation of noise detection statistic from weights and signal spectrogram
function [sigma_n] = noise_std_DS(W, S, A, Nseg, fIndex, nBinSide)
    var_n = 0;
    for tIndex = 1:Nseg
        var_n = var_n + sum(W((fIndex(tIndex)-nBinSide):(fIndex(tIndex)+nBinSide), tIndex).^2 .* abs(S((fIndex(tIndex)-nBinSide):(fIndex(tIndex)+nBinSide), tIndex)).^2)^2;
    end
    var_n = A^2*var_n;
    sigma_n = sqrt(var_n);
end

% Calculate standard deviation of noise detection statistic from weights and signal spectrogram
function [D_s] = pred_signal_DS(W, S, A, Nseg, fIndex, nBinSide)
    D_s = 0;
    for tIndex = 1:Nseg
        D_s = D_s + sum(W((fIndex(tIndex)-nBinSide):(fIndex(tIndex)+nBinSide), tIndex) .* abs(S((fIndex(tIndex)-nBinSide):(fIndex(tIndex)+nBinSide), tIndex).^2))^2;
    end
    D_s = D_s + noise_mean_DS(W, S, A, Nseg, fIndex, nBinSide);
end

% Calculate root mean square h_0 for pure signal spectrogram
function [h_0] = h0rms(S, fIndex, Nseg, nBinSide)
    h_0sqr = 0;
    for tIndex = 1:Nseg
        h_0sqr = h_0sqr + sum(abs(S((fIndex(tIndex)-nBinSide):(fIndex(tIndex)+nBinSide), tIndex)).^2);
    end
    h_0 = sqrt(h_0sqr/Nseg);
end